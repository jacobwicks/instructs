{"version":3,"sources":["types/Actions/index.ts","types/Albums/index.ts","types/Apis/index.ts","types/Bot/index.ts","types/Events/index.ts","types/Instructions/index.ts","types/Login/index.ts","types/Threads/index.ts","types/types.ts","services/InstructionsContext/index.tsx","components/TopBar/index.tsx","components/Markdown/index.tsx","services/Spacing/index.ts","services/UseResize/index.ts","components/Instructions/components/Instruction/index.tsx","components/User/index.tsx","services/GetLineHeight/index.ts","components/Instructions/components/Threads/index.tsx","components/Instructions/components/RegexTriggerDisplay/index.tsx","components/Instructions/components/TriggerInstruction/index.tsx","components/Instructions/components/AlbumActionInstruction/index.tsx","components/Instructions/components/ActionsInstructions/index.tsx","services/JSONParseRegExReviver/index.ts","components/Instructions/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ActionsActionTypes","AlbumsActionTypes","ImageReviewStatus","APITypes","ApiActionTypes","BotActionTypes","BotFetchKeys","EventsActionTypes","LogEventTypes","InstructionsActionTypes","LoginActionTypes","ThreadsActionTypes","initialState","actions","albums","bot","avatar","undefined","id","name","title","profile","regDate","botName","done","fetching","failed","general","threads","dispatch","action","reducer","state","type","instructions","console","log","InstructionsContext","createContext","InstructionsProvider","children","testState","testDispatch","useReducer","value","Provider","Title","useContext","Header","size","content","InstructionsLink","href","target","rel","menuItems","map","element","index","Menu","Item","key","TopBar","color","inverted","MyMarkdown","props","maxWidth","imageNodes","Map","renderers","image","alt","src","style","allowNodes","node","position","set","JSON","stringify","start","linkTarget","rawSourcePos","spacing","marginTop","marginBottom","useResize","myRef","getWidth","useCallback","current","offsetWidth","useState","width","setWidth","useEffect","handleResize","window","addEventListener","removeEventListener","Instruction","input","addChildren","forceOpen","open","setOpen","divRef","React","useRef","markdownChild","onClick","e","escapeHtml","source","inputName","split","replace","trim","child","preventDefault","as","forEach","push","toString","cursor","ref","Segment","User","h1","Image","getLineHeight","root","document","getElementById","text","createElement","innerHTML","appendChild","lineHeight","parseInt","getComputedStyle","fontSize","removeChild","Threads","maxHeight","zero","length","singular","overflow","thread","link","RegexTriggerDisplay","album","triggers","filter","trigger","RegExp","Label","Trigger","TriggerInstruction","example","hasRegExp","some","el","AlbumTriggersInstruction","description","hasRegex","stringChildren","AlbumActionInstruction","actionInstruction","ActionsInstructions","albumActions","notAlbumActions","reviver","test","indexOf","m","match","regExp","err","instructionsJson","require","Instructions","setInstructions","parse","Grid","Column","Container","Loader","active","App","isLocalhost","Boolean","location","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","error","rootElement","hasChildNodes","hydrate","StrictMode","render","URL","process","origin","fetch","headers","response","contentType","get","status","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.b70b0724.chunk.js","sourcesContent":["export type Trigger = string | RegExp;\r\n\r\nexport interface DisplayAction {\r\n    active: boolean;\r\n    instructions?: string;\r\n    name: string;\r\n    triggers: Trigger[];\r\n}\r\n\r\nexport enum ActionsActionTypes {\r\n    currentAction = 'currentAction',\r\n    fetchAttempt = 'fetchAttempt',\r\n    failed = 'failed',\r\n    setActions = 'setActions',\r\n    setAction = 'setAction',\r\n    setActive = 'setActive',\r\n}\r\n\r\nexport type ActionsAction =\r\n    //sets the current action that the user is viewing\r\n    | { type: ActionsActionTypes.currentAction; key: string }\r\n\r\n    //sets the entire actions object, retrieved from API\r\n    | {\r\n          type: ActionsActionTypes.setActions;\r\n          actions: { [key: string]: DisplayAction };\r\n      }\r\n    //fetching failed\r\n    | { type: ActionsActionTypes.failed }\r\n\r\n    //currently fetching\r\n    | { type: ActionsActionTypes.fetchAttempt }\r\n\r\n    //set the value of an action\r\n    | { type: ActionsActionTypes.setAction; key: string; value: DisplayAction }\r\n\r\n    //set the active value of an action\r\n    //refer to action as 'key'\r\n    | { type: ActionsActionTypes.setActive; key: string; value: boolean };\r\n\r\n//The Dispatch function\r\ninterface ActionsDispatch {\r\n    dispatch: (action: ActionsAction) => void;\r\n}\r\n\r\nexport interface ActionsType {\r\n    action?: string;\r\n    actions: { [key: string]: DisplayAction };\r\n    fetching: boolean;\r\n    failed: boolean;\r\n}\r\n\r\n//a union type. The Albums state will have a Stats object for any given key\r\n//except dispatch will return the LoggedInDispatch function\r\nexport type ActionsState = ActionsType & ActionsDispatch;\r\n","import { SAUser } from '../types';\r\n\r\nexport interface Album {\r\n    description: string;\r\n    hash: string;\r\n    status: boolean;\r\n}\r\n\r\nexport interface Albums {\r\n    [key: string]: Album;\r\n}\r\n\r\nexport enum AlbumsActionTypes {\r\n    accept = 'accept',\r\n    addExistingAlbum = 'addExistingAlbum',\r\n    createNewAlbum = 'createNewAlbum',\r\n    delete = 'delete',\r\n    deleteAlbum = 'deleteAlbum',\r\n    fetchAlbumsAttempt = 'fetchAlbumsAttempt',\r\n    fetchAlbumsFailure = 'fetchAlbumsFailure',\r\n    fetchAlbumsSuccess = 'fetchAlbumsSuccess',\r\n    pending = 'pending',\r\n    reject = 'reject',\r\n    report = 'report',\r\n    removeImage = 'removeImage',\r\n    setAlbum = 'setAlbum',\r\n    setDescription = 'setDescription',\r\n    setFetchingImageQueue = 'setFetchingImageQueue',\r\n    setHash = 'setHash',\r\n    setImageQueue = 'setImageQueue',\r\n    setName = 'setName',\r\n    setReview = 'setReview',\r\n    setStatus = 'setStatus',\r\n}\r\n\r\nexport type AlbumsAction =\r\n    //accepts adds an image to an album\r\n    | { type: AlbumsActionTypes.accept; submittedAt: string }\r\n\r\n    //adds an exisiting imgur album\r\n    | {\r\n          type: AlbumsActionTypes.addExistingAlbum;\r\n          album?: string;\r\n          description?: string;\r\n          hash: string;\r\n          status?: boolean;\r\n      }\r\n\r\n    //create a new album. user must provide the hash\r\n    | {\r\n          type: AlbumsActionTypes.createNewAlbum;\r\n          album: string;\r\n          description?: string;\r\n          hash?: string;\r\n      }\r\n\r\n    //deletes an image from the queue\r\n    | { type: AlbumsActionTypes.delete; submittedAt: string }\r\n\r\n    //delete an album. From the bot? or from imgur altogether?\r\n    | { type: AlbumsActionTypes.deleteAlbum; album: string }\r\n\r\n    //trying to fetch the albums\r\n    | { type: AlbumsActionTypes.fetchAlbumsAttempt }\r\n\r\n    //failed to fetch the albums\r\n    | { type: AlbumsActionTypes.fetchAlbumsFailure }\r\n\r\n    //got the albums from the api\r\n    | {\r\n          type: AlbumsActionTypes.fetchAlbumsSuccess;\r\n          albums: Albums;\r\n          imageQueue?: ReviewImage[];\r\n      }\r\n\r\n    //sets the status of an image to pending\r\n    | { type: AlbumsActionTypes.pending; submittedAt: string }\r\n\r\n    //reject adding an image to an album\r\n    | { type: AlbumsActionTypes.reject; submittedAt: string }\r\n\r\n    //remove an image from an album\r\n    | { type: AlbumsActionTypes.removeImage }\r\n\r\n    //the image is obscene or illegal\r\n    | { type: AlbumsActionTypes.report }\r\n\r\n    //sets the current album to string or undefined\r\n    | { type: AlbumsActionTypes.setAlbum; album?: string }\r\n\r\n    //sets the description of an album\r\n    | {\r\n          type: AlbumsActionTypes.setDescription;\r\n          album: string;\r\n          value: string;\r\n      }\r\n\r\n    //sets the fetching boolean\r\n    | {\r\n          type: AlbumsActionTypes.setFetchingImageQueue;\r\n          fetching: boolean;\r\n      }\r\n\r\n    //sets the image queue array\r\n    | {\r\n          type: AlbumsActionTypes.setImageQueue;\r\n          imageQueue: ReviewImage[];\r\n      }\r\n    //sets the name of the album\r\n    | {\r\n          type: AlbumsActionTypes.setName;\r\n          album: string;\r\n          value: string;\r\n      }\r\n    //turns image review on or off\r\n    | {\r\n          type: AlbumsActionTypes.setReview;\r\n          review?: boolean;\r\n      }\r\n\r\n    //sets the album active status\r\n    //if true, album is available for posters to invoke or request image addition\r\n    | {\r\n          type: AlbumsActionTypes.setStatus;\r\n          album: string;\r\n          value: boolean;\r\n      }\r\n\r\n    //sets the hash of an album\r\n    | { type: AlbumsActionTypes.setHash; album: string; value: string };\r\n\r\n//The Dispatch function\r\ninterface AlbumsDispatch {\r\n    dispatch: (action: AlbumsAction) => void;\r\n}\r\n\r\nexport interface AlbumsType {\r\n    album?: string;\r\n    albums?: Albums;\r\n    imageQueue?: ReviewImage[];\r\n    fetching: boolean;\r\n    hasFailed: boolean;\r\n    review: boolean;\r\n}\r\n\r\n//a union type. The Albums state will have a Stats object for any given key\r\n//except dispatch will return the LoggedInDispatch function\r\nexport type AlbumsState = AlbumsType & AlbumsDispatch;\r\n\r\n//the possible states of an image submitted to be added to an album\r\nexport enum ImageReviewStatus {\r\n    //not reviewed yet\r\n    pending = 'PENDING',\r\n\r\n    //accepted into the album\r\n    accepted = 'ACCEPTED',\r\n\r\n    //rejected from the album\r\n    rejected = 'REJECTED',\r\n\r\n    //image is obscene or illegal\r\n    reported = 'REPORTED',\r\n}\r\n\r\nexport interface ReviewImage {\r\n    album: string;\r\n    image: string;\r\n    submittedAt: string;\r\n    submittedBy: SAUser;\r\n    status: ImageReviewStatus;\r\n}\r\n","enum APITypes {\r\n    accessToken = 'accessToken',\r\n    access_token = 'access_token',\r\n    access_token_secret = 'access_token_secret',\r\n    bearerToken = 'bearerToken',\r\n    clientId = 'clientId',\r\n    clientSecret = 'clientSecret',\r\n    consumerKey = 'consumerKey',\r\n    consumerSecret = 'consumerSecret',\r\n}\r\n\r\nexport type Api = string | { [A in APITypes]?: any };\r\n\r\nexport interface Apis {\r\n    [key: string]: Api;\r\n}\r\n\r\nexport enum ApiActionTypes {\r\n    failed = 'failed',\r\n    fetching = 'fetching',\r\n    setCurrent = 'setCurrent',\r\n    setApis = 'setApis',\r\n    setApi = 'setApi',\r\n}\r\n\r\nexport type ApiAction =\r\n    //failed to fetch an api\r\n    | { type: ApiActionTypes.failed; api: string }\r\n\r\n    //getting an api\r\n    | { type: ApiActionTypes.fetching; api: string }\r\n\r\n    //setting the currently viewed api\r\n    | { type: ApiActionTypes.setCurrent; current: string }\r\n\r\n    //loading all apis\r\n    | { type: ApiActionTypes.setApis; apis: Apis }\r\n\r\n    //loading a single api\r\n    | { type: ApiActionTypes.setApi; api: string; value: Api };\r\n\r\n//The Dispatch function\r\ninterface ApiDispatch {\r\n    dispatch: React.Dispatch<ApiAction>;\r\n}\r\n\r\ninterface ApiType {\r\n    apis: Apis;\r\n    current: string;\r\n    failed: string[];\r\n    fetching: string[];\r\n}\r\n//a union type. The LoggedIn state will have a Stats object for any given key\r\n//except dispatch will return the LoggedInDispatch function\r\nexport type ApiState = ApiType & ApiDispatch;\r\n","import { Apis } from '../types';\r\n\r\n//the types of action that the reducer in BotContext will handle\r\nexport enum BotActionTypes {\r\n    decreaseInterval = 'decreaseInterval',\r\n    increaseInterval = 'increaseInterval',\r\n    fetchAttempt = 'fetchAttempt',\r\n    fetchFailure = 'fetchFailure',\r\n    fetchSuccess = 'fetchSuccess',\r\n    runOnce = 'runOnce',\r\n    setBotName = 'setBotName',\r\n    setCookies = 'setCookies',\r\n    setInterval = 'setInterval',\r\n    setRunning = 'setRunning',\r\n    setTimer = 'setTimer',\r\n    setValueAttempt = 'setValueAttempt',\r\n    setValueFailure = 'setValueFailure',\r\n    setValueSuccess = 'setValueSuccess',\r\n    start = 'start',\r\n    stop = 'stop',\r\n    testCookies = 'testCookies',\r\n}\r\n\r\nexport enum BotFetchKeys {\r\n    APIs = 'APIs',\r\n    settings = 'settings',\r\n}\r\nexport type BotAction =\r\n    //decreases the run interval\r\n    | { type: BotActionTypes.decreaseInterval }\r\n\r\n    //increases the run interval\r\n    | { type: BotActionTypes.increaseInterval }\r\n\r\n    //attempting to fetch something from the api\r\n    | { type: BotActionTypes.fetchAttempt; key: BotFetchKeys }\r\n\r\n    //fetching failed\r\n    | { type: BotActionTypes.fetchFailure; key: BotFetchKeys }\r\n\r\n    //load APIs received from API into context\r\n    | {\r\n          type: BotActionTypes.fetchSuccess;\r\n          key: BotFetchKeys;\r\n          content: Apis | FrontEndBotSettings;\r\n      }\r\n\r\n    //runs the bot once with current settings, then stops the bot\r\n    | { type: BotActionTypes.runOnce }\r\n\r\n    //sets the bot name\r\n    | { type: BotActionTypes.setBotName; botName: string }\r\n\r\n    //sets the Forum Cookies\r\n    | { type: BotActionTypes.setCookies; cookies: Cookies }\r\n\r\n    //sets if the bot is currently running or not\r\n    | { type: BotActionTypes.setRunning; running: boolean }\r\n\r\n    //sets the timer\r\n    | { type: BotActionTypes.setTimer; timer: Timer }\r\n\r\n    //starts the bot running at current intervals\r\n    | { type: BotActionTypes.start }\r\n\r\n    //stops the bot from running if it is already running\r\n    | { type: BotActionTypes.stop }\r\n\r\n    //sets the interval in minutes at which the bot runs\r\n    | { type: BotActionTypes.setInterval; interval: number }\r\n\r\n    //sets cookies.testing to true\r\n    | { type: BotActionTypes.testCookies };\r\n\r\n//The Dispatch function\r\ninterface BotDispatch {\r\n    dispatch: (action: BotAction) => void;\r\n}\r\n\r\nexport interface Cookies {\r\n    exist?: boolean;\r\n    refreshing: boolean;\r\n    testing: boolean;\r\n    work?: boolean;\r\n}\r\n\r\nexport interface FrontEndBotSettings {\r\n    //the name that posters use to get the bot's attention\r\n    botName: string;\r\n\r\n    cookies: Cookies;\r\n\r\n    //how often the bot runs in minutes, must be > 1\r\n    interval: number;\r\n\r\n    //If the bot is set to run every interval or not\r\n    on: boolean;\r\n\r\n    //if the bot is currently running or not\r\n    running: boolean;\r\n}\r\n\r\nexport interface Timer {\r\n    minutes: number;\r\n    seconds: number;\r\n}\r\n\r\ninterface BotType {\r\n    api: string;\r\n    APIs?: Apis;\r\n    fetching: string[];\r\n    hasFailed: string[];\r\n    settings?: FrontEndBotSettings;\r\n    timer: Timer;\r\n}\r\n\r\n//a union type. The LoggedIn state will have a Stats object for any given key\r\n//except dispatch will return the LoggedInDispatch function\r\nexport type BotState = BotType & BotDispatch;\r\n","export enum EventsActionTypes {\r\n    addEvent = 'addEvent',\r\n    failed = 'failed',\r\n    setListening = 'setListening',\r\n}\r\n\r\nexport type EventsAction =\r\n    //received event from event source. add it to array of LogEvents\r\n    | {\r\n          type: EventsActionTypes.addEvent;\r\n          event: LogEvent | LogEvent[];\r\n      }\r\n\r\n    //failed to get event source\r\n    | { type: EventsActionTypes.failed }\r\n\r\n    //already listening to event source\r\n    | { type: EventsActionTypes.setListening; listening: boolean };\r\n\r\nexport interface EventsDispatch {\r\n    dispatch: React.Dispatch<EventsAction>;\r\n}\r\n\r\ninterface EventsType {\r\n    events: LogEvent[];\r\n    failed: boolean;\r\n    listening: boolean;\r\n}\r\n\r\nexport type EventsState = EventsType & EventsDispatch;\r\n\r\nexport type LogEvent = {\r\n    time: string;\r\n    text?: string;\r\n    data?: object;\r\n};\r\n\r\n//the types of log events\r\nexport enum LogEventTypes {\r\n    apiMessage = 'apiMessage',\r\n    array = 'array',\r\n    botStatus = 'botStatus',\r\n    error = 'error',\r\n    instructions = 'instructions',\r\n    timeLeft = 'timeLeft',\r\n    link = 'link',\r\n    post = 'post',\r\n    setting = 'setting',\r\n    threads = 'threads',\r\n    text = 'text',\r\n}\r\n","import { Trigger, SAUser } from '../types';\r\nimport { FrontEndThread } from '../Threads';\r\n\r\nexport interface ActionInstruction {\r\n    albums: boolean;\r\n    example?: string;\r\n    instructions?: string;\r\n    key: string;\r\n    name: string;\r\n    triggers: Trigger[];\r\n}\r\n\r\nexport interface AlbumInstruction {\r\n    album: string;\r\n    description?: string;\r\n}\r\n\r\nexport enum InstructionsActionTypes {\r\n    done = 'done',\r\n    failed = 'failed',\r\n    fetchAttempt = 'fetchAttempt',\r\n    setBotName = 'setBotName',\r\n    setInstructions = 'setInstructions',\r\n}\r\n\r\nexport type InstructionsAction =\r\n    //fetching done\r\n    | { type: InstructionsActionTypes.done }\r\n\r\n    //fetching failed\r\n    | { type: InstructionsActionTypes.failed }\r\n\r\n    //currently fetching\r\n    | { type: InstructionsActionTypes.fetchAttempt }\r\n\r\n    //set the botName\r\n    | { type: InstructionsActionTypes.setBotName; botName: string }\r\n\r\n    //set the instruction state, except for botName\r\n    | {\r\n          type: InstructionsActionTypes.setInstructions;\r\n          instructions: {\r\n              actions: ActionInstruction[];\r\n              albums: AlbumInstruction[];\r\n              bot: SAUser;\r\n              botName: string;\r\n              general: string;\r\n              threads: FrontEndThread[];\r\n          };\r\n      };\r\n\r\n//The Dispatch function\r\ninterface InstructionsDispatch {\r\n    dispatch: (action: InstructionsAction) => void;\r\n}\r\n\r\nexport interface InstructionsType {\r\n    actions: ActionInstruction[];\r\n    albums: AlbumInstruction[];\r\n    bot: SAUser;\r\n    botName: string;\r\n    done: boolean;\r\n    fetching: boolean;\r\n    failed: boolean;\r\n    general: string;\r\n    threads: FrontEndThread[];\r\n}\r\n\r\n//a union type\r\nexport type InstructionsState = InstructionsType & InstructionsDispatch;\r\n","//the types of action that the reducer in BotContext will handle\r\nexport enum LoginActionTypes {\r\n    attempt = 'attempt',\r\n    failure = 'failure',\r\n    logout = 'logout',\r\n    openModal = 'openModal',\r\n    success = 'success',\r\n}\r\n\r\nexport type LoginAction =\r\n    //attempting to login, waiting for response\r\n    | { type: LoginActionTypes.attempt }\r\n\r\n    //login attempt failed\r\n    | { type: LoginActionTypes.failure }\r\n\r\n    //user logs out\r\n    | { type: LoginActionTypes.logout }\r\n\r\n    //the login modal is open or not\r\n    | { type: LoginActionTypes.openModal }\r\n\r\n    //login attempt succeeded\r\n    //token has been stored in localStorage\r\n    | { type: LoginActionTypes.success };\r\n\r\n//The Dispatch function\r\ninterface LoginDispatch {\r\n    dispatch: React.Dispatch<LoginAction>;\r\n}\r\n\r\ninterface LoginType {\r\n    isLoggedIn: boolean;\r\n    loggingIn: boolean;\r\n    modalOpen: boolean;\r\n}\r\n//a union type. The LoggedIn state will have a Stats object for any given key\r\n//except dispatch will return the LoggedInDispatch function\r\nexport type LoginState = LoginType & LoginDispatch;\r\n","interface ThreadLimits {\r\n    startPage: number;\r\n    startPost: number;\r\n    stopPage: number;\r\n    stopPost: number;\r\n}\r\n\r\n//a thread that the bot monitors\r\nexport interface FrontEndThread {\r\n    //active is true if it was bookmarked\r\n    //the last time we got bookmarked threads from the forums page\r\n    bookmarked: boolean;\r\n\r\n    //     lastScannedPage?: number;\r\n    //     lastScannedPost?: number;\r\n    //     newPosts?: number;\r\n\r\n    //optional limits on scanning the thread\r\n    //start at X page, post, stop at Y page, post\r\n    limit?: ThreadLimits;\r\n\r\n    //a link to the thread\r\n    link: string;\r\n\r\n    //human readable name\r\n    //designated by you, the person running the bot\r\n    //goes in the logs\r\n    name?: string;\r\n\r\n    //title from the forums\r\n    //this is often changed\r\n    title?: string;\r\n\r\n    //the unique identifying number of the thread\r\n    threadId: number;\r\n\r\n    pages: number;\r\n\r\n    unreadPosts: number;\r\n}\r\n\r\nexport enum ThreadsActionTypes {\r\n    addThread = 'addThread',\r\n    currentThread = 'currentThread',\r\n    failed = 'failed',\r\n    fetchAttempt = 'fetchAttempt',\r\n    setBookmarked = 'setBookmarked',\r\n    setName = 'setName',\r\n    setThreads = 'setThreads',\r\n}\r\n\r\nexport type ThreadsAction =\r\n    //add thread or array of threads  to array of threads\r\n    | {\r\n          type: ThreadsActionTypes.addThread;\r\n          thread: FrontEndThread | FrontEndThread[];\r\n      }\r\n\r\n    //set the current thread\r\n    | { type: ThreadsActionTypes.currentThread; threadId: number }\r\n\r\n    //failed to get threads from API\r\n    | { type: ThreadsActionTypes.failed }\r\n\r\n    //fetching threads from API\r\n    | { type: ThreadsActionTypes.fetchAttempt }\r\n\r\n    //set if a thread is bookmarked\r\n    | {\r\n          type: ThreadsActionTypes.setBookmarked;\r\n          threadId: number;\r\n          value: boolean;\r\n      }\r\n\r\n    //set the name of a thread\r\n    | { type: ThreadsActionTypes.setName; threadId: number; value?: string }\r\n\r\n    //set the whole array of threads\r\n    | { type: ThreadsActionTypes.setThreads; threads: FrontEndThread[] };\r\n\r\nexport interface ThreadsDispatch {\r\n    dispatch: React.Dispatch<ThreadsAction>;\r\n}\r\n\r\ninterface ThreadsType {\r\n    thread: number;\r\n    threads?: FrontEndThread[];\r\n    failed: boolean;\r\n    fetching: boolean;\r\n}\r\n\r\nexport type ThreadsState = ThreadsType & ThreadsDispatch;\r\n","export interface Creds {\r\n    username: string;\r\n    password: string;\r\n}\r\n\r\nexport interface KeyStringInterface {\r\n    [key: string]: any;\r\n}\r\n\r\nexport interface SAUser {\r\n    avatar?: string;\r\n    id: number;\r\n    name: string;\r\n    title?: string;\r\n    profile: string;\r\n    regDate: string;\r\n}\r\n\r\nexport const dummySAUser: SAUser = {\r\n    avatar: undefined,\r\n    id: 0,\r\n    name: '',\r\n    title: undefined,\r\n    profile: '',\r\n    regDate: '',\r\n};\r\n\r\nexport interface Post {\r\n    //the name of the user that wrote the post\r\n    author: SAUser;\r\n\r\n    //the body of the post, without other quoted posts inside it\r\n    body: string;\r\n\r\n    //the date the post was made\r\n    date: Date;\r\n\r\n    //the unique postId number\r\n    id: number;\r\n\r\n    //the img.src property\r\n    image?: string;\r\n\r\n    //link to the post\r\n    link: string;\r\n}\r\n\r\nexport interface Instruction extends Post {\r\n    //the instruction that the bot received\r\n    instruction: string;\r\n\r\n    //the link to the post that had the instruction\r\n    link: string;\r\n}\r\n\r\nexport * from './Actions';\r\nexport * from './Albums';\r\nexport * from './Apis';\r\nexport * from './Bot';\r\nexport * from './Events';\r\nexport * from './Instructions';\r\nexport * from './Login';\r\nexport * from './Threads';\r\n","import React, { createContext, useReducer } from 'react';\r\nimport {\r\n    InstructionsState,\r\n    InstructionsAction,\r\n    dummySAUser,\r\n} from '../../types/types';\r\n\r\nconst initialState = {\r\n    actions: [],\r\n    albums: [],\r\n    bot: dummySAUser,\r\n    botName: '',\r\n    done: false,\r\n    fetching: false,\r\n    failed: false,\r\n    general: '',\r\n    threads: [],\r\n    dispatch: (action: InstructionsAction) => undefined,\r\n} as InstructionsState;\r\n\r\n// }\r\n\r\nlet reducer = (state: InstructionsState, action: InstructionsAction) => {\r\n    switch (action.type) {\r\n        case 'done': {\r\n            return {\r\n                ...state,\r\n                done: true,\r\n                fetching: false,\r\n            };\r\n        }\r\n        case 'failed': {\r\n            return {\r\n                ...state,\r\n                actions: [],\r\n                albums: [],\r\n                done: true,\r\n                fetching: false,\r\n                failed: true,\r\n                general: '',\r\n            };\r\n        }\r\n        // setInstructions = 'setInstructions',\r\n        case 'fetchAttempt': {\r\n            return {\r\n                ...state,\r\n                fetching: true,\r\n            };\r\n        }\r\n        case 'setBotName': {\r\n            const { botName } = action;\r\n            return {\r\n                ...state,\r\n                botName,\r\n            };\r\n        }\r\n        case 'setInstructions': {\r\n            const { instructions } = action;\r\n            const {\r\n                actions,\r\n                albums,\r\n                bot,\r\n                botName,\r\n                general,\r\n                threads,\r\n            } = instructions;\r\n            console.log('set instructions here');\r\n            return {\r\n                ...state,\r\n                failed: false,\r\n                fetching: false,\r\n                actions,\r\n                albums,\r\n                bot,\r\n                botName,\r\n                general,\r\n                threads,\r\n            };\r\n        }\r\n        default: {\r\n            console.log(`InstructionsContext default`, action);\r\n            //throw new Error();\r\n            return state;\r\n        }\r\n    }\r\n};\r\n\r\nconst InstructionsContext = createContext(initialState);\r\n\r\n//the Props that the InstructionsProvider will accept\r\ntype InstructionsProps = {\r\n    //You can put react components inside of the Provider component\r\n    children: React.ReactNode;\r\n\r\n    //We might want to pass a state into the CardProvider for testing purposes\r\n    testState?: InstructionsState;\r\n\r\n    testDispatch?: (args: any) => void;\r\n};\r\n\r\nconst InstructionsProvider = ({\r\n    children,\r\n    testState,\r\n    testDispatch,\r\n}: InstructionsProps) => {\r\n    //useReducer returns an array containing the state at [0]\r\n    //and the dispatch method at [1]\r\n    //use array destructuring to get state and dispatch\r\n    const [state, dispatch] = useReducer(\r\n        reducer,\r\n        testState ? testState : initialState\r\n    );\r\n\r\n    //add dispatch to value object and cast to LoggedInState\r\n    const value = {\r\n        ...state,\r\n        dispatch,\r\n    } as InstructionsState;\r\n\r\n    return (\r\n        <InstructionsContext.Provider value={value}>\r\n            {children}\r\n        </InstructionsContext.Provider>\r\n    );\r\n};\r\n\r\nexport { InstructionsContext, InstructionsProvider };\r\n","import React, { useContext } from 'react';\r\nimport { Header, Menu } from 'semantic-ui-react';\r\nimport { InstructionsContext } from '../../services/InstructionsContext';\r\n\r\nconst Title = () => {\r\n    const { botName } = useContext(InstructionsContext);\r\n\r\n    return <Header size=\"large\" content={`${botName}, an SA Forums Bot`} />;\r\n};\r\n\r\nconst InstructionsLink = () => (\r\n    <a\r\n        href={'https://jacobwicks.github.io/2020/07/01/forums-posting-bot.html'}\r\n        target=\"_blank\"\r\n        rel=\"noopener noreferrer\"\r\n    >\r\n        How to run your own forums bot\r\n    </a>\r\n);\r\n\r\nconst menuItems = [<Title />, <InstructionsLink />].map((element, index) => (\r\n    <Menu.Item key={index}>{element}</Menu.Item>\r\n));\r\n\r\nconst TopBar = () => <Menu children={menuItems} color=\"green\" inverted />;\r\n\r\nexport default TopBar;\r\n","import React from 'react';\r\nimport ReactMarkdown from 'react-markdown/with-html';\r\n\r\nconst MyMarkdown = (props: any) => {\r\n    //the maximum width of an image in the markdown\r\n    const maxWidth = props?.maxWidth;\r\n\r\n    const imageNodes = new Map();\r\n    const nodeKey = (position: any) => JSON.stringify(position.start); // or use your own hash function\r\n\r\n    const allowNodes = (node: any) => {\r\n        if (node.type === 'image') imageNodes.set(nodeKey(node.position), node);\r\n        return true;\r\n    };\r\n\r\n    //ReactMarkdown accepts custom renderers\r\n    const renderers = {\r\n        //This custom renderer changes how images are rendered\r\n        //we use it to constrain the max width of an image to its container\r\n        image: ({ alt, src, title }: { alt: any; src: any; title: any }) => (\r\n            <img alt={alt} src={src} title={title} style={{ maxWidth }} />\r\n        ),\r\n    };\r\n\r\n    return (\r\n        <ReactMarkdown\r\n            {...props}\r\n            allowNodes={allowNodes}\r\n            linkTarget={'_blank'}\r\n            renderers={renderers}\r\n            rawSourcePos\r\n        />\r\n    );\r\n};\r\n\r\nexport default MyMarkdown;\r\n","export const spacing = { marginTop: 10, marginBottom: 10 };\r\n","import { useCallback, useEffect, useState } from 'react';\r\n\r\nconst useResize = (myRef: any) => {\r\n    const getWidth = useCallback(() => myRef?.current?.offsetWidth, [myRef]);\r\n\r\n    const [width, setWidth] = useState<number | undefined>(undefined);\r\n\r\n    useEffect(() => {\r\n        const handleResize = () => {\r\n            setWidth(getWidth());\r\n        };\r\n\r\n        if (myRef.current) {\r\n            setWidth(getWidth());\r\n        }\r\n\r\n        window.addEventListener('resize', handleResize);\r\n\r\n        return () => {\r\n            window.removeEventListener('resize', handleResize);\r\n        };\r\n    }, [getWidth, myRef]);\r\n\r\n    return width && width > 25 ? width - 25 : width;\r\n};\r\n\r\nexport default useResize;\r\n","import React, { useState } from 'react';\r\nimport { Segment, Header } from 'semantic-ui-react';\r\nimport ReactMarkdown from '../../../Markdown';\r\nimport { spacing } from '../../../../services/Spacing';\r\nimport useResize from '../../../../services/UseResize';\r\n\r\nexport const Instruction = ({\r\n    input,\r\n    name,\r\n    addChildren,\r\n    forceOpen,\r\n}: {\r\n    forceOpen?: boolean;\r\n    input: string;\r\n    name: string;\r\n    addChildren?: JSX.Element[];\r\n}) => {\r\n    const [open, setOpen] = useState(!!forceOpen);\r\n    const divRef = React.useRef<HTMLDivElement>(null);\r\n    const maxWidth = useResize(divRef);\r\n\r\n    const markdownChild = (\r\n        <div onClick={(e) => !forceOpen && setOpen(false)}>\r\n            <ReactMarkdown\r\n                key=\"markdown\"\r\n                escapeHtml={false}\r\n                source={input}\r\n                maxWidth={maxWidth}\r\n            />\r\n        </div>\r\n    );\r\n\r\n    const inputName = input.split(/\\r?\\n/)[0].replace('#', '').trim();\r\n\r\n    const child = (\r\n        <div\r\n            onClick={(e) => {\r\n                e.preventDefault();\r\n                setOpen(true);\r\n            }}\r\n        >\r\n            <Header as=\"h3\">{inputName ? inputName : name}</Header>\r\n        </div>\r\n    );\r\n\r\n    const children = [open ? markdownChild : child];\r\n\r\n    if (open) {\r\n        addChildren?.forEach((child, index) =>\r\n            children.push({ ...child, key: index.toString() })\r\n        );\r\n    }\r\n\r\n    const style = forceOpen ? spacing : { ...spacing, cursor: 'pointer' };\r\n    return (\r\n        <div ref={divRef} style={style}>\r\n            <Segment children={children} />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Instruction;\r\n","import React from 'react';\r\nimport { Header, Image } from 'semantic-ui-react';\r\nimport { SAUser } from '../../types/types';\r\n\r\nconst User = ({ avatar, name, regDate, title }: SAUser) => (\r\n    <div>\r\n        <Header h1 content={name} />\r\n        {regDate}\r\n        <br />\r\n        <br />\r\n        {avatar && <Image src={avatar} />}\r\n        {title}\r\n    </div>\r\n);\r\n\r\nexport default User;\r\n","const getLineHeight = () => {\r\n    //to get the line height\r\n    const root = document.getElementById('root');\r\n    const text = document.createElement('span');\r\n    text.innerHTML = 'Hello';\r\n    //add an element containing some text\r\n    root?.appendChild(text);\r\n\r\n    //find the height\r\n    const lineHeight = parseInt(window.getComputedStyle(text).fontSize, 10);\r\n    //remove the element\r\n    root?.removeChild(text);\r\n    return lineHeight;\r\n};\r\n\r\nexport default getLineHeight;\r\n","import React, { useContext } from 'react';\r\nimport { Header, Segment } from 'semantic-ui-react';\r\nimport { InstructionsContext } from '../../../../services/InstructionsContext';\r\nimport getLineHeight from '../../../../services/GetLineHeight';\r\n\r\nconst Threads = () => {\r\n    const { botName, threads } = useContext(InstructionsContext);\r\n    const lineHeight = getLineHeight();\r\n\r\n    const lines = 5;\r\n\r\n    const maxHeight = lineHeight ? (lines + 1) * lineHeight : 100;\r\n\r\n    const zero = !threads.length;\r\n    const singular = threads.length === 1;\r\n    return (\r\n        <Segment>\r\n            <Header as=\"h2\">\r\n                {botName} is currently {zero ? 'not ' : ''}watching{' '}\r\n                {zero ? 'any ' : threads.length} thread{singular ? '' : 's'}\r\n            </Header>\r\n            <div style={{ maxHeight, overflow: 'auto' }}>\r\n                {threads.map((thread, index) => (\r\n                    <div key={index}>\r\n                        <a\r\n                            href={thread.link}\r\n                            target=\"_blank\"\r\n                            rel=\"noopener noreferrer\"\r\n                        >\r\n                            {thread.title}\r\n                        </a>\r\n                    </div>\r\n                ))}\r\n            </div>\r\n        </Segment>\r\n    );\r\n};\r\n\r\nexport default Threads;\r\n","import React from 'react';\r\nimport ReactMarkdown from '../../../Markdown';\r\nimport { Segment, Header, Label } from 'semantic-ui-react';\r\nimport { Trigger } from '../../../../types/types';\r\nimport { spacing } from '../../../../services/Spacing';\r\nimport useResize from '../../../../services/UseResize';\r\n\r\nexport const RegexTriggerDisplay = ({\r\n    album,\r\n    input,\r\n    triggers,\r\n}: {\r\n    album?: string;\r\n    input?: string;\r\n    triggers: Trigger[];\r\n}) => {\r\n    const divRef = React.useRef<HTMLDivElement>(null);\r\n    const maxWidth = useResize(divRef);\r\n\r\n    if (album) {\r\n        input = input?.replace(/\\${album}/g, album);\r\n    }\r\n\r\n    return (\r\n        <Segment>\r\n            {!!input?.length ? (\r\n                <div ref={divRef}>\r\n                    <ReactMarkdown\r\n                        key=\"markdown\"\r\n                        escapeHtml={false}\r\n                        source={input}\r\n                        maxWidth={maxWidth}\r\n                    />{' '}\r\n                </div>\r\n            ) : (\r\n                <>\r\n                    <Header as=\"h4\">\r\n                        No example given to match regular expression trigger\r\n                    </Header>\r\n                    {triggers\r\n                        .filter((trigger) => trigger instanceof RegExp)\r\n                        .map((trigger, index) => (\r\n                            <div key={index} style={spacing}>\r\n                                <Label color=\"blue\">RegExp</Label>{' '}\r\n                                {trigger.toString()}\r\n                            </div>\r\n                        ))}\r\n                </>\r\n            )}\r\n        </Segment>\r\n    );\r\n};\r\n\r\nexport default RegexTriggerDisplay;\r\n","import React, { useContext } from 'react';\r\nimport { spacing } from '../../../../services/Spacing';\r\nimport { Segment, Header } from 'semantic-ui-react';\r\nimport { Trigger as TriggerType } from '../../../../types/types';\r\nimport RegexTriggerDisplay from '../RegexTriggerDisplay';\r\nimport { InstructionsContext } from '../../../../services/InstructionsContext';\r\n\r\nconst Trigger = ({ trigger }: { trigger: TriggerType }) => {\r\n    const { botName } = useContext(InstructionsContext);\r\n    return (\r\n        <Segment>\r\n            {botName} {trigger.toString()}\r\n        </Segment>\r\n    );\r\n};\r\n\r\nconst TriggerInstruction = ({\r\n    example,\r\n    triggers,\r\n}: {\r\n    example?: string;\r\n    triggers: TriggerType[];\r\n}) => {\r\n    const hasRegExp = triggers.some((el) => el instanceof RegExp);\r\n\r\n    return !!triggers.length ? (\r\n        <Segment>\r\n            <Header as=\"h3\">How to trigger this action</Header>\r\n            <div style={spacing}>\r\n                {triggers.map(\r\n                    (trigger, index) =>\r\n                        !(trigger instanceof RegExp) && (\r\n                            <Trigger key={index} trigger={trigger} />\r\n                        )\r\n                )}\r\n            </div>\r\n            {hasRegExp && (\r\n                <RegexTriggerDisplay input={example} triggers={triggers} />\r\n            )}\r\n        </Segment>\r\n    ) : (\r\n        <Segment>\r\n            <Header as=\"h2\">No triggers set for this action</Header>\r\n        </Segment>\r\n    );\r\n};\r\n\r\nexport default TriggerInstruction;\r\n","import React, { useContext } from 'react';\r\nimport { InstructionsContext } from '../../../../services/InstructionsContext';\r\nimport { Segment, Header } from 'semantic-ui-react';\r\nimport { ActionInstruction } from '../../../../types/types';\r\nimport Instruction from '../Instruction';\r\nimport { Trigger } from '../../../../types/types';\r\nimport RegexTriggerDisplay from '../RegexTriggerDisplay';\r\n\r\nconst AlbumTriggersInstruction = ({\r\n    album,\r\n    description,\r\n    example,\r\n    triggers,\r\n}: {\r\n    album: string;\r\n    description?: string;\r\n    example?: string;\r\n    triggers: Trigger[];\r\n}) => {\r\n    const { botName } = useContext(InstructionsContext);\r\n    const hasRegex = triggers.some((trigger) => trigger instanceof RegExp);\r\n\r\n    const stringChildren = triggers\r\n        .filter((trigger) => !(trigger instanceof RegExp))\r\n        .map((trigger, key) => (\r\n            <Segment key={key}>\r\n                <div>\r\n                    {botName} {trigger} {album}\r\n                </div>\r\n            </Segment>\r\n        ));\r\n\r\n    return (\r\n        <>\r\n            <Header as=\"h4\">\r\n                {album} {description ? `- ${description}` : ''}\r\n            </Header>\r\n            {hasRegex && (\r\n                <RegexTriggerDisplay\r\n                    album={album}\r\n                    input={example}\r\n                    triggers={triggers}\r\n                />\r\n            )}\r\n            {stringChildren}\r\n        </>\r\n    );\r\n};\r\n\r\n//instruction for an action that deals with albums\r\nconst AlbumActionInstruction = ({\r\n    actionInstruction,\r\n}: {\r\n    actionInstruction: ActionInstruction;\r\n}) => {\r\n    const { albums } = useContext(InstructionsContext);\r\n\r\n    const { example, instructions, key, name, triggers } = actionInstruction;\r\n\r\n    const addChildren = !!albums.length\r\n        ? albums.map(({ album, description }, key) => (\r\n              <AlbumTriggersInstruction\r\n                  key={key}\r\n                  album={album}\r\n                  description={description}\r\n                  example={example}\r\n                  triggers={triggers}\r\n              />\r\n          ))\r\n        : [\r\n              <AlbumTriggersInstruction\r\n                  key=\"placeholder\"\r\n                  album={'placeHolder'}\r\n                  description={\r\n                      'This bot has no active albums. This placeholder is here as an example'\r\n                  }\r\n                  example={example}\r\n                  triggers={triggers}\r\n              />,\r\n          ];\r\n\r\n    return (\r\n        <Instruction\r\n            addChildren={addChildren}\r\n            input={instructions || ''}\r\n            key={key}\r\n            name={name}\r\n        />\r\n    );\r\n};\r\n\r\nexport default AlbumActionInstruction;\r\n","import React, { useContext } from 'react';\r\nimport { Segment, Header } from 'semantic-ui-react';\r\nimport { InstructionsContext } from '../../../../services/InstructionsContext';\r\nimport TriggerInstruction from '../TriggerInstruction';\r\nimport Instruction from '../Instruction';\r\nimport AlbumActionInstruction from '../AlbumActionInstruction';\r\n\r\nconst ActionsInstructions = () => {\r\n    const { actions } = useContext(InstructionsContext);\r\n\r\n    const albumActions = actions.filter((action) => action.albums);\r\n    const notAlbumActions = actions.filter((action) => !action.albums);\r\n\r\n    return (\r\n        <Segment>\r\n            <Header as=\"h2\">Actions - click for description</Header>\r\n            {albumActions.map((actionInstruction) => (\r\n                <AlbumActionInstruction actionInstruction={actionInstruction} />\r\n            ))}\r\n            {notAlbumActions?.map(\r\n                ({ example, instructions, key, name, triggers }) => (\r\n                    <Instruction\r\n                        input={instructions || ''}\r\n                        key={key}\r\n                        name={name}\r\n                        addChildren={[\r\n                            <TriggerInstruction\r\n                                example={example}\r\n                                triggers={triggers}\r\n                            />,\r\n                        ]}\r\n                    />\r\n                )\r\n            )}\r\n        </Segment>\r\n    );\r\n};\r\n\r\nexport default ActionsInstructions;\r\n","export const regExpPrefix = '__REGEXP ';\r\n\r\nexport const reviver = (key: string, value: any, test?: boolean) => {\r\n    if (value.toString().indexOf(regExpPrefix) === 0) {\r\n        try {\r\n            var m = value.split(regExpPrefix)[1].match(/\\/(.*)\\/(.*)?/);\r\n            const regExp = new RegExp(m[1], m[2] || '');\r\n            return test ? true : regExp;\r\n        } catch (err) {\r\n            return test ? false : 'failedRegex';\r\n        }\r\n    } else return value;\r\n};\r\n","import React, { useEffect, useContext } from 'react';\r\nimport { Loader, Grid } from 'semantic-ui-react';\r\nimport { Container } from 'semantic-ui-react';\r\nimport Instruction from './components/Instruction';\r\nimport { InstructionsContext } from '../../services/InstructionsContext';\r\nimport User from '../User';\r\nimport Threads from './components/Threads';\r\nimport ActionsInstructions from './components/ActionsInstructions';\r\nimport { InstructionsActionTypes } from '../../types/types';\r\nimport { reviver } from '../../services/JSONParseRegExReviver';\r\nconst instructionsJson = require('../../instructions.json');\r\n\r\nconst Instructions = () => {\r\n    const { dispatch, actions, bot, general } = useContext(InstructionsContext);\r\n\r\n    useEffect(() => {\r\n        dispatch({\r\n            type: InstructionsActionTypes.setInstructions,\r\n            instructions: JSON.parse(JSON.stringify(instructionsJson), reviver),\r\n        });\r\n    }, [dispatch]);\r\n\r\n    if (!actions) return <Loader active />;\r\n\r\n    return (\r\n        <Grid>\r\n            <Grid.Column width={3}>{bot && <User {...bot} />}</Grid.Column>\r\n            <Grid.Column width={13}>\r\n                <Container>\r\n                    {general ? (\r\n                        <>\r\n                            <Instruction\r\n                                name=\"\"\r\n                                input={general}\r\n                                forceOpen={true}\r\n                            />\r\n                            <Threads />\r\n                            <ActionsInstructions />\r\n                        </>\r\n                    ) : (\r\n                        <Loader active />\r\n                    )}\r\n                </Container>\r\n            </Grid.Column>\r\n        </Grid>\r\n    );\r\n};\r\n\r\nexport default Instructions;\r\n","import React from 'react';\r\nimport './App.css';\r\nimport TopBar from './components/TopBar';\r\nimport { Container } from 'semantic-ui-react';\r\nimport Instructions from './components/Instructions';\r\nimport { InstructionsProvider } from './services/InstructionsContext';\r\n\r\nconst App = () => (\r\n    <InstructionsProvider>\r\n        <TopBar />\r\n        <Container text>\r\n            <Instructions />\r\n        </Container>\r\n    </InstructionsProvider>\r\n);\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\n//import ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport { hydrate, render } from 'react-dom';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nconst rootElement = document.getElementById('root');\r\nif (rootElement?.hasChildNodes()) {\r\n    hydrate(\r\n        <React.StrictMode>\r\n            <App />\r\n        </React.StrictMode>,\r\n        rootElement\r\n    );\r\n} else {\r\n    render(\r\n        <React.StrictMode>\r\n            <App />\r\n        </React.StrictMode>,\r\n        rootElement\r\n    );\r\n}\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.register();\r\n"],"sourceRoot":""}